<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>å…ƒä»¶åœ–è½‰æ–‡å­—æ•˜è¿°</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    #output-container {
      margin-top: 20px;
      border: 1px solid #ccc;
      padding: 10px;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.5;
      background: #f9f9f9;
    }
    strong { font-weight: bold; }
  </style>
</head>
<body>
  <h2>ä¸Šå‚³å…ƒä»¶åœ– JSON æª”</h2>
  <input type="file" accept=".json" onchange="handleFile(event)" />
  <div id="output-container"><em>è½‰æ›çµæœå°‡é¡¯ç¤ºåœ¨æ­¤è™•...</em></div>
  <br />
  <button onclick="downloadText()">ğŸ“¥ ä¸‹è¼‰ TXT</button>

  <script>
    let rawText = "";
    
    // å°‡ id å­—ä¸²è½‰å›ç‰©ä»¶ï¼ˆç”¨æ–¼ fallbackï¼‰
    function parseIdString(idStr = "") {
      const obj = {};
      idStr.split("|").forEach((pair) => {
        const [k, ...rest] = pair.split(":");
        if (k && rest.length) obj[k] = rest.join(":");
      });
      return obj;
    }
    
    // è™•ç†ä¸Šå‚³
    function handleFile(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const graph = JSON.parse(e.target.result);
          rawText = convertGraphToText(graph, false);
          const html = convertGraphToText(graph, true);
          document.getElementById("output-container").innerHTML = html;
        } catch (err) {
          alert("âŒ JSON æ ¼å¼éŒ¯èª¤ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆå…§å®¹ï¼");
        }
      };
      reader.readAsText(file);
    }
    
    // çµ±ä¸€æ ¼å¼åŒ–è¼¸å‡º
    function formatDetailedLabel(node = {}) {
      return (
        `[name]: ${node.name || "æœªçŸ¥"}  ` +
        `[filename]: ${node.filename || "æœªçŸ¥"}  ` +
        `[type]: ${node.type || "æœªçŸ¥"}  ` +
        `[placeType]: ${node.placeType || "æœªçŸ¥"}`
      );
    }
    
    function convertGraphToText(graph, generateHTML = false) {
  const groups = { frontend: {}, server: {}, mysql: {} };
  const idMap = {};
  const edgeMap = {};
  const reverseEdgeMap = {};

  // å»ºç«‹ ID â†’ ç¯€é» æ˜ å°„
  graph.nodes.forEach((n) => (idMap[n.id] = n));

  // è™•ç†é‚Š
  graph.edges.forEach((edge) => {
    const fromNode = typeof edge.from === "object" ? edge.from : parseIdString(edge.from);
    const toNode   = typeof edge.to === "object"   ? edge.to   : parseIdString(edge.to);
    const fromId   = fromNode.id || edge.from;
    const toId     = toNode.id   || edge.to || "unknown";

    if (!edgeMap[fromId]) edgeMap[fromId] = [];
    if (!reverseEdgeMap[toId]) reverseEdgeMap[toId] = [];

    const toLabel = formatDetailedLabel(toNode);
    const fromLabel = formatDetailedLabel(fromNode);

    edgeMap[fromId].push(`â¤ (${edge.type}) â†’ ${toLabel}`);
    reverseEdgeMap[toId].push(`â† (${edge.type}) ${fromLabel}`);
  });

  // åˆ†çµ„ç¯€é»
  graph.nodes.forEach((node) => {
    const zone = node.placeType || "server";
    const file = node.filename || "(ç„¡æª”å)";
    if (!groups[zone][file]) groups[zone][file] = [];
    groups[zone][file].push({
      name: node.name,
      type: node.type,
      description: node.description || "",
      edges: edgeMap[node.id] || [],
      reverseEdges: reverseEdgeMap[node.id] || [],
    });
  });

  // è¼¸å‡ºæ ¼å¼åŒ–æ–‡å­—æˆ– HTML
  function line(label, value) {
    if (generateHTML) {
      const htmlVal = value.replace(/\n/g, "<br>");
      return `<div><strong>${label}ï¼š</strong>${htmlVal}</div>`;
    }
    return `${label}ï¼š${value}`;
  }

  let out = "";
  for (const zone of ["frontend", "server", "mysql"]) {
    out += generateHTML
      ? `<strong>ğŸ”·ã€${zone.toUpperCase()} å€åŸŸã€‘</strong>\n`
      : `ğŸ”·ã€${zone.toUpperCase()} å€åŸŸã€‘\n`;

    for (const file in groups[zone]) {
      out += (generateHTML ? "<hr />" : "------") + "\n";  // ğŸ”¸ æ©«ç·šåœ¨æª”åä¸Šé¢
      out += line("ğŸ“„ æª”æ¡ˆ", file) + "\n";

      groups[zone][file].forEach((n) => {
        out += "\n" + line("ğŸ§© å…ƒä»¶åç¨±", n.name) + "\n"; // ğŸ”¸ æ”¹ç‚º name
        out += line("é¡å‹", n.type) + "\n";
        out += line("èªªæ˜", n.description) + "\n";

        if (n.edges.length) {
          out += line("ğŸ”— é€£å‡ºå»", "") + "\n  " + n.edges.join("\n  ") + "\n";
        } else {
          out += line("ğŸ”— é€£å‡ºå»", "ç„¡") + "\n";
        }

        if (n.reverseEdges.length) {
          out += line("ğŸ”™ è¢«é€£å…¥", "") + "\n  " + n.reverseEdges.join("\n  ") + "\n";
        } else {
          out += line("ğŸ”™ è¢«é€£å…¥", "ç„¡") + "\n";
        }
      });
    }

    out += "\n" + (generateHTML ? `<hr />` : "-".repeat(40) + "\n");
  }

  return out.trim();
}

    
    // ä¸‹è¼‰ TXT åŠŸèƒ½
    function downloadText() {
      const blob = new Blob([rawText], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "graph_description.txt";
      a.click();
      URL.revokeObjectURL(url);
    }
    </script>
    
</body>
</html>

